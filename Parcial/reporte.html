<h1>Parcial - tema2</h1>
<p>Nota: 9.0 / 10.0 (APROBADO)</p>
<pre><code>puntaje ej1: 2
puntaje ej2: 2
puntaje ej3: 2
puntaje ej4: 2
puntaje ej5: 1
puntaje ej6: 0.0
</code></pre>
<h2>Datos del alumno</h2>
<p>Nombre: Massimo Luca Pozzuto</p>
<p>DNI: 47030345</p>
<p>LU: 1051/25</p>
<p>Maquina: 11-05</p>
<h2>Enunciado</h2>
<!doctype html>
<html>
<head>
  <link rel="icon" href="data:,">
  <link href="css/style.css" rel="stylesheet" />
  <meta charset="UTF-8">
</head>

<body>
  <div>
    <h1>Parcial Haskell - Tema 2 - Turno mañana</h1>

    <h2>Importante</h2>
    <p>
      Template de funciones a implementar <a href="#" onclick="forceDownload('/parcial/Template_t2.hs','SolucionT2.hs');">acá</a><br>
      Lista de funciones permitidas <a href="/static/haskell_permitidas.html" target="_blank" rel="noopener noreferrer">acá</a><br>
      Ejemplo de hunit <a href="#" onclick="forceDownload('/parcial/Test_template_t2.hs','Test_template_t2.hs');">acá</a>
    </p>

    <form name="form1" action="/submit_examen" method="post" enctype="multipart/form-data" onsubmit="return validaciones(event)">
      <h2>Enunciado</h2>

      <ol>
          <p>
            Resolver los siguientes ejercicios cuyas especificaciones en lenguaje semiformal figuran a continuación. 
            Deben ser implementadas en Haskell utilizando los tipos requeridos y solamente las funciones que se ven 
            en la materia Introducción a la Programación / Algoritmos y Estructuras de Datos I (FCEyN-UBA).
          </p>

        <li>
          <strong>Ejercicio 1 (2 puntos)</strong>
          <p>
            problema esCuadradoDePrimo (<i>n</i>: Z) : Bool {<br>
            &nbsp; <strong>requiere:</strong> {n > 1} <br>
            &nbsp; <strong>asegura:</strong> {<i>res</i> = true ⇔ Existe un número primo p tal que p² = n} <br>
            }<br>
          </p>

          <pre style="background-color: #f0f0f0; /* Color de fondo del recuadro */
padding: 2px; /* Espacio interior */
border: 1px solid #ccc; /* Borde del recuadro */
border-radius: 5px; /* Bordes redondeados */">
Ejemplo 1: <b>esCuadradoDePrimo 9</b> debe devolver <b>True</b>
Ejemplo 2: <b>esCuadradoDePrimo 16</b> debe devolver <b>False</b>
          </pre>
        </li>

        <li>
          <strong>Ejercicio 2 (2 puntos)</strong>
          <p>
            problema posParesFormanEscalera (<i>lista</i>: seq⟨Z⟩) : Bool {<br>
            &nbsp; <strong>requiere:</strong> {True} <br>
            &nbsp; <strong>asegura:</strong> {<i>res</i> = true ⇔ Para todo número par <i>i</i> tal que 0 ≤ i < |lista|-2, se cumple que lista[i+2] = lista[i] + 1} <br>
            }<br>
          </p>

          <pre style="background-color: #f0f0f0; /* Color de fondo del recuadro */
padding: 2px; /* Espacio interior */
border: 1px solid #ccc; /* Borde del recuadro */
border-radius: 5px; /* Bordes redondeados */">
Ejemplo 1: <b>posParesFormanEscalera [1,5,2,8,3]</b> debe devolver <b>True</b>
Ejemplo 2: <b>posParesFormanEscalera [1,2,3,4]</b> debe devolver <b>False</b>
          </pre>
        </li>

        <li>
          <strong>Ejercicio 3 (2 puntos)</strong>
          <p>
            Recibimos de una importante productora el listado de películas estrenadas, agrupadas por año
            (es decir, en una tupla de la forma (Año, [Título])). Debemos pasarle
            a una famosa plataforma de streaming el listado de tuplas película/año de estreno disponibles.
          </p>

                      <p>
              problema listadoDePeliculas (<i>pelisPorAnio</i>: seq⟨Z x seq⟨String⟩⟩) : seq⟨⟨String x Z⟩⟩ {<br>
              &nbsp; <strong>requiere:</strong> {Las primeras componentes de <i>pelisPorAnio</i> son todas distintas} <br>
              &nbsp; <strong>requiere:</strong> {En cada tupla de <i>pelisPorAnio</i>, en la segunda componente no hay repetidos} <br>
              &nbsp; <strong>asegura:</strong> {<i>res</i> es una lista de tuplas donde cada tupla contiene un título de película y su año de estreno, de acuerdo a los datos ingresados en <i>pelisPorAnio</i>} <br>
              &nbsp; <strong>asegura:</strong> {Para cada película en <i>pelisPorAnio</i>, existe una tupla correspondiente en <i>res</i> con el título y año correctos y viceversa} <br>
              &nbsp; <strong>asegura:</strong> {<i>res</i> no contiene elementos repetidos} <br>
              }<br>
            </p>

          <pre style="background-color: #f0f0f0; /* Color de fondo del recuadro */
padding: 2px; /* Espacio interior */
border: 1px solid #ccc; /* Borde del recuadro */
border-radius: 5px; /* Bordes redondeados */">
Ejemplo 1: <b>listadoDePeliculas [(2019,["Parasite","Joker"]),(2021,["Dune"])]</b> puede devolver <b>[("Parasite",2019),("Joker",2019),("Dune",2021)]</b>
Ejemplo 2: <b>listadoDePeliculas [(2019,["Avengers: Endgame"])]</b> debe devolver <b>[("Avengers: Endgame",2019)]</b>
          </pre>
        </li>

        <li>
          <strong>Ejercicio 4 (2 puntos)</strong>
          <p>
            Dada una matriz de números enteros, eliminar la primera fila que tenga la suma máxima.
          </p>
          <p>
            problema eliminarFilaQueMasSuma (<i>mat</i>: seq⟨seq⟨Z⟩⟩) : seq⟨seq⟨Z⟩⟩ {<br>
            &nbsp; <strong>requiere:</strong> {|<i>mat</i>| > 0} <br>
            &nbsp; <strong>requiere:</strong> {Todos los elementos de <i>mat</i> tienen la misma longitud (y dicha longitud es estrictamente mayor a 0)} <br>
            &nbsp; <strong>asegura:</strong> {|<i>res</i>| = |<i>mat</i>| - 1} <br>
            &nbsp; <strong>asegura:</strong> {<i>res</i> contiene todas las filas de <i>mat</i> (con los mismos elementos y en el mismo orden)
              excepto la primera que tiene suma máxima} <br>
            }<br>
          </p>

          <pre style="background-color: #f0f0f0; /* Color de fondo del recuadro */
padding: 2px; /* Espacio interior */
border: 1px solid #ccc; /* Borde del recuadro */
border-radius: 5px; /* Bordes redondeados */">
Ejemplo 1: <b>eliminarFilaQueMasSuma [[1,2],[3,4],[1,1],[6,1]]</b> debe devolver <b>[[1,2],[1,1],[6,1]]</b>
          </pre>
        </li>

        <li>
          <strong>Ejercicio 5 (1 punto)</strong>
          <p>
            Conteste marcando la opción correcta asumiendo que &alpha; y &beta; son dos fórmulas de la lógica proposicional 
            tales que &alpha; es más fuerte que &beta;, y que se tiene las siguientes especificaciones:
          </p>

           <table style="width: 100%; border-collapse: collapse;">
             <tr>
               <td style="width: 50%; padding: 10px; vertical-align: top;">
                 <strong>problema1 (...)</strong> {<br>
                 &nbsp; <strong>requiere:</strong> {&alpha;} <br>
                 &nbsp; <strong>asegura:</strong> {&gamma;} <br>
                 }
               </td>
               <td style="width: 50%; padding: 10px; vertical-align: top;">
                 <strong>problema2 (...)</strong> {<br>
                 &nbsp; <strong>requiere:</strong> {&beta;} <br>
                 &nbsp; <strong>asegura:</strong> {&gamma;} <br>
                 }
               </td>
             </tr>
           </table>
          <p>
            <input type="radio" name="mchoice_1" id="opcion1" value="1" />
            <label for="opcion1">Una correcta implementación de <b>problema1</b> va a contemplar al menos los mismos casos de entrada que una correcta implementación del <b>problema2</b></label> <br>
            <input type="radio" name="mchoice_1" id="opcion2" value="2" />
            <label for="opcion2">Una correcta implementación de <b>problema2</b> va a contemplar al menos los mismos casos de entrada que una correcta implementación del <b>problema1</b></label> <br>
            <input type="radio" name="mchoice_1" id="opcion3" value="3" />
            <label for="opcion3">No es posible afirmar ninguna de las opciones sin conocer en detalle ambas especificaciones</label> <br>
          </p>
        </li>


        <li>
          <strong>Ejercicio 6 (1 punto)</strong>
          <p>
            Respecto al testing de caja negra, conteste marcando la opción correcta asumiendo que se cuenta con la siguiente especificación:
          </p>

          <p>
            problema unaFuncionQueHaceAlgo (<i>n</i>: Z) : Z {<br>
            &nbsp; <strong>requiere:</strong> {True} <br>
            &nbsp; <strong>asegura:</strong> {<i>res</i> > n } <br>
            &nbsp; <strong>asegura:</strong> {<i>res</i> es un número par} <br>
            }<br>
          </p>

          <p>
            <input type="radio" name="mchoice_2" id="opcion1_2" value="1" />
            <label for="opcion1_2"><i>n</i> = 3, <i>res</i> = 4 es un caso de test válido</label> <br>
            <input type="radio" name="mchoice_2" id="opcion2_2" value="2" />
            <label for="opcion2_2">Si queremos testear el caso de <i>n</i> = 3, debemos armar un test suite con al menos 2 
              casos de test, uno para validar que <i>res</i> > <i>n</i> y otro para validar que <i>res</i> es un número par</label> <br>
            <input type="radio" name="mchoice_2" id="opcion3_2" value="3" />
            <label for="opcion3_2">Un buen test suite debería incluir casos en los cuales n toma valores pares, impares, positivos y negativos</label> <br>
          </p>
        </li>
      </ol>

      <hr>
      <h3 style="color:#1A5276">Adjunta el archivo con tu solución:</h3>
      <p><b style="color:red">Solo se puede adjuntar 1 archivo de extensión .hs. En caso de haber desarrollado tests propios, no deben ser entregados.</b></p>

      <label for="archivo">Seleccionar archivo a enviar:</label>
      <input type="file" id="archivo" name="archivo" required accept=".hs,text/x-haskell" />

      <input type="submit" value="Enviar" style="background-color: #1A5276; border-radius: 5px;
                margin-top:10px;padding: 10px 150px;color: #FFFFFF;
                font-size: 20px;cursor: pointer; width:100%">
    </form>
  </div>

  <script>
    function validaciones(event) {
      var confirmacion = confirm("Confirmo que revise mis respuestas y que quiero entregar mi examen");
      if (!confirmacion) {
        event.preventDefault();
        event.returnValue = false;
        return false;
      }
      event.returnValue = true;
      return true;
    }

    // registro una funcion para mostrar el archivo cuando se adjunta.
    // de esa forma evitamos que se adjunten otros archivos por error
    document
      .getElementById('archivo')
      .addEventListener(
        'change',
        function () {
          var fr = new FileReader();
          fr.onload = function () {
            alert(this.result);
          };
          fr.readAsText(this.files[0]);
        }
      );

    // para forzar a bajar el template de hunit y que no se pueda abrir en un nuevo tab
    // (el browser intenta mostrar el codigo como HTML y el formato se ve raro)
    function forceDownload(url, filename) {
      fetch(url).then(function (t) {
        return t.blob().then((b) => {
          var a = document.createElement("a");
          a.href = URL.createObjectURL(b);
          a.setAttribute("download", filename);
          a.click();
        });
      });
    }
  </script>
</body>
</html>

<h2>Solucion entregada por el alumno</h2>
<pre><code>{--
Yo: Massimo Luca Pozzuto
Certifico que el siguiente archivo fue elaborado únicamente por mí, sin ayuda de otras personas o herramientas.
--}

module SolucionT2 where

-- Ejercicio 1 
-- ^
esCuadradoDePrimo :: Integer -&gt; Bool
esCuadradoDePrimo numero = esCuadradoDePrimoAux numero 1

esCuadradoDePrimoAux :: Integer -&gt; Integer -&gt; Bool
esCuadradoDePrimoAux n i 
    | n &lt; (proximoPrimo i)^2 = False
    | n == (proximoPrimo i)^2 = True
    | otherwise = esCuadradoDePrimoAux n (i+1) 

proximoPrimo :: Integer -&gt; Integer
proximoPrimo 1 = 2
proximoPrimo n 
    | esPrimo (n+1) = n+1
    | otherwise = proximoPrimo (n+1)

esPrimo :: Integer -&gt; Bool
esPrimo n = esPrimoAux n 2

esPrimoAux :: Integer -&gt; Integer -&gt; Bool
esPrimoAux n i 
    | n &lt; 2 = False
    | n == i = True
    | mod n i == 0 = False
    | otherwise = esPrimoAux n (i+1)


-- Ejercicio 2
posParesFormanEscalera :: [Integer] -&gt; Bool
posParesFormanEscalera [] = True
posParesFormanEscalera lista = posParesFormanEscaleraAux lista 0

posParesFormanEscaleraAux :: [Integer] -&gt; Integer -&gt; Bool
posParesFormanEscaleraAux [x] _ = True
posParesFormanEscaleraAux [x, y] _ = True
posParesFormanEscaleraAux (x:xs) i
    | not posEsPar = posParesFormanEscaleraAux xs (i+1)
    | (x+1 == iesimoElemento xs 1 ) = posParesFormanEscaleraAux xs (i+1)
    | otherwise = False
    where
        posEsPar = mod i 2 == 0

iesimoElemento :: [t] -&gt; Integer -&gt; t
iesimoElemento (x:xs) 0 = x 
iesimoElemento (x:xs) i = iesimoElemento xs (i-1)


-- Ejercicio 3
listadoDePeliculas :: [(Integer, [String])] -&gt; [(String, Integer)]
listadoDePeliculas [] = []
listadoDePeliculas (primerAnio: otrosAnios) = eliminarRepetidos (listadoDePeliculasDeUnAnio primerAnio ++ listadoDePeliculas otrosAnios)

-- Asumo que las tuplas deben ser exactamente iguales para estar repetidas, por ejemplo: (&quot;Dune&quot;, 2021) /= (&quot;Dune&quot;, 2019)
eliminarRepetidos :: [(String, Integer)] -&gt; [(String, Integer)]
eliminarRepetidos [] = []
eliminarRepetidos ((peli, anio): otrasPelis)
    | laPeliActualEstaEnLasOtras = eliminarRepetidos otrasPelis
    | otherwise = (peli, anio): eliminarRepetidos otrasPelis
    where
        laPeliActualEstaEnLasOtras = pertenece (peli, anio) otrasPelis

pertenece :: (Eq t) =&gt; t -&gt; [t] -&gt; Bool
pertenece _ [] = False
pertenece el (x:xs)
    | el == x = True
    | otherwise = pertenece el xs

quitarPeli :: String -&gt; [(String, Integer)] -&gt; [(String, Integer)]
quitarPeli _ [] = []
quitarPeli peliDeseada ((peli, anio): otrasPelis)
    | peliDeseada == peli = quitarPeli peliDeseada otrasPelis
    | otherwise = (peli, anio) : quitarPeli peliDeseada otrasPelis

listadoDePeliculasDeUnAnio :: (Integer, [String]) -&gt; [(String, Integer)]
listadoDePeliculasDeUnAnio (_, []) = []
listadoDePeliculasDeUnAnio (anio, (peli: otrasPelis)) = (peli, anio) : listadoDePeliculasDeUnAnio (anio, otrasPelis)


-- Ejercicio 4
eliminarFilaQueMasSuma :: [[Integer]] -&gt; [[Integer]]
eliminarFilaQueMasSuma [] = []
eliminarFilaQueMasSuma [fila] = []
eliminarFilaQueMasSuma (fila : otrasFilas) 
    | sumatoria fila &gt;= maximaSumatoriaFilas otrasFilas = otrasFilas
    | otherwise = fila : eliminarFilaQueMasSuma otrasFilas

maximaSumatoriaFilas :: [[Integer]] -&gt; Integer
maximaSumatoriaFilas [fila] = sumatoria fila
maximaSumatoriaFilas (fila : otrasFilas) 
    | sumatoria fila &gt;= maximaSumatoriaFilas otrasFilas = sumatoria fila
    | otherwise = maximaSumatoriaFilas otrasFilas

sumatoria :: (Num t) =&gt; [t] -&gt; t 
sumatoria [] = 0
sumatoria (x:xs) = x + sumatoria xs

{--
Siendo la última modificación con la solución final:
01/10/2025 11:22
--}

</code></pre>
<h2>Resultado de la compilacion</h2>
<pre><code>Loaded package environment from /home/virginia-brassesco/.ghc/x86_64-linux-9.4.7/environments/default
[1 of 1] Compiling SolucionT2       ( correcciones/parcialtm_funcional/pozzuto_massimo_luca_47030345/submission.hs.main.hs, correcciones/parcialtm_funcional/pozzuto_massimo_luca_47030345/submission.hs.main.o )

</code></pre>
<h2>Ejecucion de los tests</h2>
<h3>tema2-test-ej1.hs.compilacion.out</h3>
<p>Puntaje del ej: 2 / 2</p>
<pre><code>

Cases: 6  Tried: 1  Errors: 0  Failures: 0

Cases: 6  Tried: 2  Errors: 0  Failures: 0

Cases: 6  Tried: 3  Errors: 0  Failures: 0

Cases: 6  Tried: 4  Errors: 0  Failures: 0

Cases: 6  Tried: 5  Errors: 0  Failures: 0


Cases: 6  Tried: 6  Errors: 0  Failures: 0


Cases: 6  Tried: 6  Errors: 0  Failures: 0

</code></pre>
<h3>tema2-test-ej2.hs.compilacion.out</h3>
<p>Puntaje del ej: 2 / 2</p>
<pre><code>

Cases: 11  Tried: 1  Errors: 0  Failures: 0

Cases: 11  Tried: 2  Errors: 0  Failures: 0

Cases: 11  Tried: 3  Errors: 0  Failures: 0

Cases: 11  Tried: 4  Errors: 0  Failures: 0

Cases: 11  Tried: 5  Errors: 0  Failures: 0

Cases: 11  Tried: 6  Errors: 0  Failures: 0

Cases: 11  Tried: 7  Errors: 0  Failures: 0

Cases: 11  Tried: 8  Errors: 0  Failures: 0

Cases: 11  Tried: 9  Errors: 0  Failures: 0

Cases: 11  Tried: 10  Errors: 0  Failures: 0


Cases: 11  Tried: 11  Errors: 0  Failures: 0


Cases: 11  Tried: 11  Errors: 0  Failures: 0

</code></pre>
<h3>tema2-test-ej3.hs.compilacion.out</h3>
<p>Puntaje del ej: 2 / 2</p>
<pre><code>

Cases: 6  Tried: 1  Errors: 0  Failures: 0

Cases: 6  Tried: 2  Errors: 0  Failures: 0

Cases: 6  Tried: 3  Errors: 0  Failures: 0

Cases: 6  Tried: 4  Errors: 0  Failures: 0

Cases: 6  Tried: 5  Errors: 0  Failures: 0


Cases: 6  Tried: 6  Errors: 0  Failures: 0


Cases: 6  Tried: 6  Errors: 0  Failures: 0

</code></pre>
<h3>tema2-test-ej4.hs.compilacion.out</h3>
<p>Puntaje del ej: 2 / 2</p>
<pre><code>

Cases: 6  Tried: 1  Errors: 0  Failures: 0

Cases: 6  Tried: 2  Errors: 0  Failures: 0

Cases: 6  Tried: 3  Errors: 0  Failures: 0

Cases: 6  Tried: 4  Errors: 0  Failures: 0

Cases: 6  Tried: 5  Errors: 0  Failures: 0


Cases: 6  Tried: 6  Errors: 0  Failures: 0


Cases: 6  Tried: 6  Errors: 0  Failures: 0

</code></pre>
<h3>mchoice.json-ej5.compilacion.out</h3>
<p>Puntaje del ej: 1 / 1</p>
<pre><code>mchoice ej5: respuesta del alumno=2, respuesta correcta=2

Ran 1 test in 0 seconds

OK

</code></pre>
<h3>mchoice.json-ej6.compilacion.out</h3>
<p>Puntaje del ej: 0.0 / 1</p>
<pre><code>mchoice ej6: respuesta del alumno=2, respuesta correcta=3

Ran 1 test in 0 seconds

FAILED (failures=1)

</code></pre>
<p>FIN</p>